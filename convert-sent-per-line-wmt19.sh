#!/bin/bash

# Created by argbash-init v2.8.1
# ARG_OPTIONAL_SINGLE([output-folder])
# ARG_OPTIONAL_BOOLEAN([fi-en])
# ARG_OPTIONAL_BOOLEAN([kk-en])
# ARG_HELP([<The general help message of my script>])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die() {
    local _ret=$2
    test -n "$_ret" || _ret=1
    test "$_PRINT_HELP" = yes && print_help >&2
    echo "$1" >&2
    exit ${_ret}
}

begins_with_short_option() {
    local first_option all_short_options='h'
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_output_folder="./wmt19-data"
_arg_fi_en="off"
_arg_kk_en="off"

print_help() {
    printf '%s\n' "<The general help message of my script>"
    printf 'Usage: %s [--output-folder <arg>] [--(no-)fi-en] [--(no-)kk-en] [-h|--help]\n' "$0"
    printf '\t%s\n' "-h, --help: Prints help"
}

parse_commandline() {
    while test $# -gt 0; do
        _key="$1"
        case "$_key" in
        --output-folder)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_output_folder="$2"
            shift
            ;;
        --output-folder=*)
            _arg_output_folder="${_key##--output-folder=}"
            ;;
        --no-fi-en | --fi-en)
            _arg_fi_en="on"
            test "${1:0:5}" = "--no-" && _arg_fi_en="off"
            ;;
        --no-kk-en | --kk-en)
            _arg_kk_en="on"
            test "${1:0:5}" = "--no-" && _arg_kk_en="off"
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        -h*)
            print_help
            exit 0
            ;;
        *)
            _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
            ;;
        esac
        shift
    done
}

parse_commandline "$@"

fi_train_files=(
    "europarl-v9.fi-en.tsv"
    "en-fi.bicleaner07.tmx"
    "rapid2016.en-fi.tmx"
)
fi_dev_files=(
    "newstest2018-enfi-ref.fi"
    "newstest2018-enfi-src.en"
    "newstest2018-fien-ref.en"
    "newstest2018-fien-src.fi"
)

fi_test_files=(
    "newstest2019-enfi-ref.fi"
    "newstest2019-enfi-src.en"
    "newstest2019-fien-ref.en"
    "newstest2019-fien-src.fi"
)

kk_train_files=(
    "news-commentary-v14-wmt19.en-kk.tsv"
    "wikititles-v1.kk-en.tsv"
)
kk_test_files=(
    "newstest2019-enkk-ref.kk"
    "newstest2019-enkk-src.en"
    "newstest2019-kken-ref.en"
    "newstest2019-kken-src.kk"
)

kk_dev_files=(
    "newsdev2019-enkk-ref.kk"
    "newsdev2019-enkk-src.en"
    "newsdev2019-kken-ref.en"
    "newsdev2019-kken-src.kk"
)

extract_fi() {
    local raw_data_folder="${_arg_output_folder}/fi-en/raw"
    local interim_data_folder="${_arg_output_folder}/fi-en/interim"
    local output_data_folder="${_arg_output_folder}/fi-en/final"

    # step 0: handling TMX and tsv files
    for f in "${fi_train_files[@]}"; do
        if [ "${f}" = "europarl-v9.fi-en.tsv" ]; then
            cut -f 1 "${raw_data_folder}/train/${f}" >"${raw_data_folder}/train/${f//.tsv/.fi}"
            cut -f 2 "${raw_data_folder}/train/${f}" >"${raw_data_folder}/train/${f//.tsv/.en}"
        else
            cat "${raw_data_folder}/train/${f}" |
                python tmx-extract-parallel.py \
                    -b "${f//.tmx/}" -s "en" -t "fi"
        fi
    done
    mv ./*en-fi* "${raw_data_folder}/train/"
    mv ./*rapid2016* "${raw_data_folder}/train/"

    # step 1: concatenate everything together
    for lang in "en" "fi"; do cat ${raw_data_folder}/train/*.${lang} >"${interim_data_folder}/train/train.${lang}"; done

    # step 2: strip extraneous XML
    for f in "${fi_dev_files[@]}"; do
        sgm_to_txt <"${raw_data_folder}/dev/${f}.sgm" >"${raw_data_folder}/dev/${f//.sgm/}"
    done
    for f in "${fi_test_files[@]}"; do
        sgm_to_txt <"${raw_data_folder}/test/${f}.sgm" >"${raw_data_folder}/test/${f//.sgm/}"
    done

    # step 3: concatenate everything together
    for lang in "en" "fi"; do cat ${raw_data_folder}/dev/*.${lang} >"${interim_data_folder}/dev/dev.${lang}"; done
    for lang in "en" "fi"; do cat ${raw_data_folder}/"test"/*.${lang} >"${interim_data_folder}/test/test.${lang}"; done
}

extract_kk() {
    local raw_data_folder="${_arg_output_folder}/kk-en/raw"
    local interim_data_folder="${_arg_output_folder}/kk-en/interim"
    local output_data_folder="${_arg_output_folder}/kk-en/final"

    # step 0: handling tsv files
    for f in "${kk_train_files[@]}"; do
        if [ "${f}" = "news-commentary-v14-wmt19.en-kk.tsv" ]; then
            cut -f 1 "${raw_data_folder}/train/${f}" >"${raw_data_folder}/train/${f//.tsv/.en}"
            cut -f 2 "${raw_data_folder}/train/${f}" >"${raw_data_folder}/train/${f//.tsv/.kk}"
        elif [ "${f}" = "wikititles-v1.kk-en.tsv" ]; then
            cut -f 1 "${raw_data_folder}/train/${f}" >"${raw_data_folder}/train/${f//.tsv/.kk}"
            cut -f 2 "${raw_data_folder}/train/${f}" >"${raw_data_folder}/train/${f//.tsv/.en}"
        fi
    done

    # step 1: concatenate everything together
    for lang in "en" "kk"; do cat ${raw_data_folder}/train/*.${lang} >"${interim_data_folder}/train/train.${lang}"; done

    # step 2: strip extraneous XML
    for f in "${kk_dev_files[@]}"; do
        sgm_to_txt <"${raw_data_folder}/dev/${f}.sgm" >"${raw_data_folder}/dev/${f//.sgm/}"
    done
    for f in "${kk_test_files[@]}"; do
        sgm_to_txt <"${raw_data_folder}/test/${f}.sgm" >"${raw_data_folder}/test/${f//.sgm/}"
    done

    # step 3: concatenate everything together
    for lang in "en" "kk"; do 
        cat ${raw_data_folder}/dev/*enkk*.${lang} >"${interim_data_folder}/dev/dev.enkk.${lang}"
        cat ${raw_data_folder}/dev/*kken*.${lang} >"${interim_data_folder}/dev/dev.kken.${lang}"
    done
    for lang in "en" "kk"; do 
        cat ${raw_data_folder}/"test"/*enkk*.${lang} >"${interim_data_folder}/test/test.enkk.${lang}" 
        cat ${raw_data_folder}/"test"/*kken*.${lang} >"${interim_data_folder}/test/test.kken.${lang}"
    done
}

sgm_to_txt() {
    grep "^<seg" |
        sed "s/<seg id\=\"[0-9]\+\">//g" |
        sed "s/<\/seg>//g"
}
# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

printf 'Value of --%s: %s\n' 'output-folder' "$_arg_output_folder"
printf "'%s' is %s\\n" 'fi-en' "$_arg_fi_en"
printf "'%s' is %s\\n" 'kk-en' "$_arg_kk_en"

[ "${_arg_fi_en}" = "on" ] && extract_fi "${_arg_output_folder}"
[ "${_arg_kk_en}" = "on" ] && extract_kk "${_arg_output_folder}"

# ] <-- needed because of Argbash
