#!/bin/bash

#set -exo pipefail

# NOTE: THIS SCRIPT USES ARGBASH TO SET UP COMMAND LINE ARGUMENTS

# Created by argbash-init v2.8.1
# ARG_OPTIONAL_SINGLE([input])
# ARG_OPTIONAL_SINGLE([output])
# ARG_OPTIONAL_SINGLE([lang])
# ARG_OPTIONAL_SINGLE([kind])
# ARG_OPTIONAL_SINGLE([model])
# ARG_OPTIONAL_SINGLE([model-binary])
# ARG_OPTIONAL_SINGLE([bpe-size])
# ARG_OPTIONAL_SINGLE([codes])
# ARG_HELP([<The general help message of my script>])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die() {
    local _ret=$2
    test -n "$_ret" || _ret=1
    test "$_PRINT_HELP" = yes && print_help >&2
    echo "$1" >&2
    exit ${_ret}
}

begins_with_short_option() {
    local first_option all_short_options='h'
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_input=
_arg_output=
_arg_lang=
_arg_kind=
_arg_model=
_arg_model_binary=
_arg_bpe_size=
_arg_codes=

print_help() {
    USAGE_MSG="""
    Usage: bash segment.sh --input <untokenized input file> 
                           --output <tokenized output file> 
                           --lang <name of language> 
                           --kind <train/valid/test> 
                           --model <type of model we are using>
                           --model-binary <path to model binary>
                           [--bpe-size <bpe size>]
                           [--codes <codes file for bpe>]
"""
    printf '\n%s\n' "segment.sh -- a script for subword segmentation using Morfessor / Flatcat / LMVR / subword-nmt"
    echo "$USAGE_MSG"
}

parse_commandline() {
    while test $# -gt 0; do
        _key="$1"
        case "$_key" in
        --input)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_input="$2"
            shift
            ;;
        --input=*)
            _arg_input="${_key##--input=}"
            ;;
        --output)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_output="$2"
            shift
            ;;
        --output=*)
            _arg_output="${_key##--output=}"
            ;;
        --lang)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_lang="$2"
            shift
            ;;
        --lang=*)
            _arg_lang="${_key##--lang=}"
            ;;
        --kind)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_kind="$2"
            shift
            ;;
        --kind=*)
            _arg_kind="${_key##--kind=}"
            ;;
        --model)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_model="$2"
            shift
            ;;
        --model=*)
            _arg_model="${_key##--model=}"
            ;;
        --model-binary)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_model_binary="$2"
            shift
            ;;
        --model-binary=*)
            _arg_model_binary="${_key##--model-binary=}"
            ;;
        --bpe-size)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_bpe_size="$2"
            shift
            ;;
        --bpe-size=*)
            _arg_bpe_size="${_key##--bpe-size=}"
            ;;
        --codes)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_codes="$2"
            shift
            ;;
        --codes=*)
            _arg_codes="${_key##--codes=}"
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        -h*)
            print_help
            exit 0
            ;;
        *)
            _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
            ;;
        esac
        shift
    done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# Validate the command line arguments that were passed in
validate() {
    [ -z "$1" ] && print_help && exit 1
}

for var in "$_arg_input" "$_arg_output" "$_arg_lang" "$_arg_model" "$_arg_model_binary"; do
    validate "$var"
done

ROOT=$(dirname "$0")
MF_SEGMENT_COMMAND="python $ROOT/segment-sentences-morfessor.py"
STITCH_COMMAND="python $ROOT/stitch-segmentations-together.py"

# Set up the segmentation functions
segment_morfessor_baseline() {
    echo "Segmenting with Morfessor Baseline..."
    INPUT_FILE=$1
    MODEL_BINARY=$2
    OUTPUT_FILE=$3
    LANGUAGE=$4

    $MF_SEGMENT_COMMAND \
        -i "$INPUT_FILE" \
        -o "$OUTPUT_FILE" \
        -m "$MODEL_BINARY" \
        --lang foo
}

segment_flatcat() {

    INPUT_FILE=$1
    MODEL_BINARY=$2
    OUTPUT_FILE=$3
    LANGUAGE=$4

    echo "Segmenting with Flatcat..."
    $MF_SEGMENT_COMMAND \
        -i "$INPUT_FILE" \
        -o "$OUTPUT_FILE" \
        -m "$MODEL_BINARY" \
        --lang foo
}

segment_subword_nmt() {

    INPUT_FILE=$1
    BPE_SIZE=$2
    OUTPUT_FILE=$3
    CODES_FILE=$4
    LANGUAGE=$5

    # on
    TRAIN_MODE=$(echo $INPUT_FILE | grep "train\.all")
    if [ ! -z "$TRAIN_MODE" ]; then
        echo "Concatentaed training set detected!"
        echo "BPE Size: $BPE_SIZE"
        echo "Input: $INPUT_FILE"
        echo "Codes: $CODES_FILE"
        echo "Output: $OUTPUT_FILE"
        echo "Learning BPE with subword-nmt..."

        subword-nmt learn-bpe \
            -t -s "$BPE_SIZE" \
            <"$INPUT_FILE" \
            >"$CODES_FILE"
    else
        echo "Non-concatenated dataset!"
        echo "Not learning BPE..."

        echo "BPE Size: $BPE_SIZE"
        echo "Input: $INPUT_FILE"
        echo "Codes: $CODES_FILE"
        echo "Output: $OUTPUT_FILE"

        echo "Applying BPE with subword-nmt..."
        subword-nmt apply-bpe \
            -c "$CODES_FILE" \
            <"$INPUT_FILE" \
            >"$OUTPUT_FILE"
    fi

}

segment_lmvr() {

    echo "performing lmvr segmentation..."
    INPUT_FILE=$1
    MODEL_BINARY=$2
    OUTPUT_FILE=$3
    LANGUAGE=$4
    KIND=$5

    OUTPUT_FOLDER_PATH=$(dirname "$OUTPUT_FILE")
    LMVR_SEGM_OUTPUT_FNAME="$OUTPUT_FOLDER_PATH/$KIND.lmvr.intermediate.$LANGUAGE"

    lmvr-segment \
        "$MODEL_BINARY" \
        "$INPUT_FILE" \
        -p 10 \
        --output-newlines \
        --encoding "utf-8" \
        -o "$LMVR_SEGM_OUTPUT_FNAME"

    echo "stitching sentences together..."
    $STITCH_COMMAND \
        --input-path "$LMVR_SEGM_OUTPUT_FNAME" \
        --output-path "$OUTPUT_FILE" \
        --model-type "lmvr" \
        --convert-to-bpe \
        --bpe-separator "@@"

}

segment_lmvr_tuned() {

    echo "performing lmvr segmentation..."
    INPUT_FILE=$1
    MODEL_BINARY=$2
    OUTPUT_FILE=$3
    LANGUAGE=$4
    KIND=$5

    OUTPUT_FOLDER_PATH=$(dirname "$OUTPUT_FILE")
    LMVR_SEGM_OUTPUT_FNAME="$OUTPUT_FOLDER_PATH/$KIND.lmvr-tuned.intermediate.$LANGUAGE"

    lmvr-segment \
        "$MODEL_BINARY" \
        "$INPUT_FILE" \
        -p 10 \
        --output-newlines \
        --encoding "utf-8" \
        -o "$LMVR_SEGM_OUTPUT_FNAME"

    echo "stitching sentences together..."
    $STITCH_COMMAND \
        --input-path "$LMVR_SEGM_OUTPUT_FNAME" \
        --output-path "$OUTPUT_FILE" \
        --model-type "lmvr-tuned"

}
# Perform segmentation with the correct model
case "$_arg_model" in
baseline)
    segment_morfessor_baseline \
        "$_arg_input" \
        "$_arg_model_binary" \
        "$_arg_output" \
        "$_arg_lang"
    ;;
flatcat)
    segment_flatcat \
        "$_arg_input" \
        "$_arg_model_binary" \
        "$_arg_output" \
        "$_arg_lang"
    ;;
lmvr)
    validate "$_arg_kind"
    segment_lmvr \
        "$_arg_input" \
        "$_arg_model_binary" \
        "$_arg_output" \
        "$_arg_lang" \
        "$_arg_kind"
    ;;
lmvr-tuned)
    validate "$_arg_kind"
    segment_lmvr_tuned \
        "$_arg_input" \
        "$_arg_model_binary" \
        "$_arg_output" \
        "$_arg_lang" \
        "$_arg_kind"
    ;;
subword-nmt)
    validate "$_arg_bpe_size"
    segment_subword_nmt \
        "$_arg_input" \
        "$_arg_bpe_size" \
        "$_arg_output" \
        "$_arg_codes" \
        "$_arg_lang"
    ;;
*)
    _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected model type '$_arg_model'. Supported: baseline, flatcat, lmvr, lmvr-tuned, subword-nmt" 1
    ;;
esac

# ] <-- needed because of Argbash
