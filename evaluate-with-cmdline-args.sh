#!/bin/bash

# Created by argbash-init v2.8.1
# ARG_OPTIONAL_SINGLE([src])
# ARG_OPTIONAL_SINGLE([tgt])
# ARG_OPTIONAL_SINGLE([segmentation-method])
# ARG_OPTIONAL_SINGLE([bpe-size])
# ARG_OPTIONAL_SINGLE([cuda-device])
# ARG_OPTIONAL_SINGLE([results-folder])
# ARG_OPTIONAL_SINGLE([checkpoint-folder])
# ARG_HELP([Script for evaluating Flores with command line args.])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

set -euo pipefail

die() {
    local _ret=$2
    test -n "$_ret" || _ret=1
    test "$_PRINT_HELP" = yes && print_help >&2
    echo "$1" >&2
    exit ${_ret}
}

begins_with_short_option() {
    local first_option all_short_options='h'
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_src=
_arg_tgt=
_arg_segmentation_method=
_arg_bpe_size=5000
_arg_cuda_device=0
_arg_results_folder=
_arg_checkpoint_folder=

print_help() {
    printf '%s\n' "Script for evaluating Flores experiments with command line args"
    printf 'Usage: %s [--src <arg>] [--tgt <arg>] [--segmentation-method <arg>] [--bpe-size <arg>] [--cuda-device <arg>] [--results-folder <arg>] [--checkpoint-folder <arg>] [-h|--help]\n' "$0"
    printf '\t%s\n' "-h, --help: Prints help"
}

parse_commandline() {
    while test $# -gt 0; do
        _key="$1"
        case "$_key" in
        --src)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_src="$2"
            shift
            ;;
        --src=*)
            _arg_src="${_key##--src=}"
            ;;
        --tgt)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_tgt="$2"
            shift
            ;;
        --tgt=*)
            _arg_tgt="${_key##--tgt=}"
            ;;
        --segmentation-method)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_segmentation_method="$2"
            shift
            ;;
        --segmentation-method=*)
            _arg_segmentation_method="${_key##--segmentation-method=}"
            ;;
        --bpe-size)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_bpe_size="$2"
            shift
            ;;
        --bpe-size=*)
            _arg_bpe_size="${_key##--bpe-size=}"
            ;;
        --cuda-device)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_cuda_device="$2"
            shift
            ;;
        --cuda-device=*)
            _arg_cuda_device="${_key##--cuda-device=}"
            ;;
        --results-folder)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_results_folder="$2"
            shift
            ;;
        --results-folder=*)
            _arg_results_folder="${_key##--results-folder=}"
            ;;
        --checkpoint-folder)
            test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
            _arg_checkpoint_folder="$2"
            shift
            ;;
        --checkpoint-folder=*)
            _arg_checkpoint_folder="${_key##--checkpoint-folder=}"
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        -h*)
            print_help
            exit 0
            ;;
        *)
            _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
            ;;
        esac
        shift
    done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# Begin custom functions

evaluate_fairseq() {
    SRC_LANG=$1
    TGT_LANG=$2
    CHECKPOINT_PATH=$3
    DATA_DIR=$4
    CUDA_DEVICE=$5

    if [ "$SRC_LANG" = "en" ]; then
        CUDA_VISIBLE_DEVICES=$CUDA_DEVICE fairseq-generate \
            $DATA_DIR \
            --source-lang $SRC_LANG --target-lang $TGT_LANG \
            --path $CHECKPOINT_PATH \
            --beam 5 --lenpen 1.2 \
            --gen-subset test \
            --remove-bpe=sentencepiece # note: no sacrebleu here
    else
        CUDA_VISIBLE_DEVICES=$CUDA_DEVICE fairseq-generate \
            $DATA_DIR \
            --source-lang $SRC_LANG --target-lang $TGT_LANG \
            --path $CHECKPOINT_PATH \
            --beam 5 --lenpen 1.2 \
            --gen-subset test \
            --remove-bpe=sentencepiece \
            --sacrebleu
    fi
}

evaluate() {
    SRC_LANG=$1
    TGT_LANG=$2
    SEGM_METHOD=$3
    BPE_SIZE=$4
    CUDA_DEVICE=$5
    RESULTS_DIR=$6
    CHECKPOINT_DIR=$7

    if [ -z $CUDA_DEVICE ]; then
        CUDA_DEVICE=0
    fi

    if [ -z $BPE_SIZE ]; then
        BPE_SIZE=5000
    fi

    if [ -z $RESULTS_DIR ]; then
        RESULTS_DIR="./evaluate/"$(ls -t ./evaluate | head -1)
    fi

    echo "BPE size is: "$BPE_SIZE

    # create path for log file
    RESULTS_FILE="baseline_"$SRC_LANG"_"$TGT_LANG".log"
    RESULTS_OUTPUT_PATH="$RESULTS_DIR/$RESULTS_FILE"
    echo "Saving output to: $RESULTS_OUTPUT_PATH"

    # infer checkpoint directory
    CHECKPOINT_PATH="${CHECKPOINT_DIR}/checkpoints_${SRC_LANG}_${TGT_LANG}/checkpoint_best.pt"
    echo "CHECKPOINT_PATH is: $CHECKPOINT_PATH"

    # create data directory
    if [ "$SRC_LANG" = "si" ] || [ "$TGT_LANG" = "si" ]; then
        DATA_DIR_PREFIX="data-bin/wiki_si_en"
    else
        DATA_DIR_PREFIX="data-bin/wiki_ne_en"
    fi

    case "$SEGM_METHOD" in
    sentencepiece-joint)
        DATA_DIR="${DATA_DIR_PREFIX}_bpe${BPE_SIZE}_joint"
        ;;
    sentencepiece-nonjoint)
        DATA_DIR="${DATA_DIR_PREFIX}_bpe${BPE_SIZE}_nonjoint"
        ;;
    sentencepiece-lowercase)
        DATA_DIR="${DATA_DIR_PREFIX}_bpe${BPE_SIZE}_lowercase"
        ;;
    subword-nmt)
        DATA_DIR="${DATA_DIR_PREFIX}_bpe${BPE_SIZE}_subwordnmt"
        ;;
    morfessor-baseline)
        DATA_DIR="${DATA_DIR_PREFIX}_morfessorbaseline"
        ;;
    morfessor-flatcat | flatcat)
        DATA_DIR="${DATA_DIR_PREFIX}_flatcat"
        ;;
    lmvr)
        DATA_DIR="${DATA_DIR_PREFIX}_lmvr"
        ;;
    morsel)
        DATA_DIR="${DATA_DIR_PREFIX}_morsel"
        ;;
    *)
        die "FATAL ERROR: Got an unexpected segmentation method! '$1'" 1
        ;;
    esac

    echo "Data folder is: ${DATA_DIR}" >>"$LOG_OUTPUT_PATH"
    echo "About to evaluate..."
    evaluate_fairseq \
        "$SRC_LANG" \
        "$TGT_LANG" \
        "$CHECKPOINT_PATH" \
        "$DATA_DIR" \
        "$CUDA_DEVICE" >"$RESULTS_OUTPUT_PATH"

}
# End custom functions

printf 'Value of --%s: %s\n' 'src' "$_arg_src"
printf 'Value of --%s: %s\n' 'tgt' "$_arg_tgt"
printf 'Value of --%s: %s\n' 'segmentation-method' "$_arg_segmentation_method"
printf 'Value of --%s: %s\n' 'bpe-size' "$_arg_bpe_size"
printf 'Value of --%s: %s\n' 'cuda-device' "$_arg_cuda_device"
printf 'Value of --%s: %s\n' 'results-folder' "$_arg_results_folder"
printf 'Value of --%s: %s\n' 'checkpoint-folder' "$_arg_checkpoint_folder"

evaluate \
    "${_arg_src}" \
    "${_arg_tgt}" \
    "${_arg_segmentation_method}" \
    "${_arg_bpe_size}" \
    "${_arg_cuda_device}" \
    "${_arg_results_folder}" \
    "${_arg_checkpoint_folder}"

# ] <-- needed because of Argbash
